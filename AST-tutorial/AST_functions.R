filter_SNPs <- function(SNP_gene_bed,exons,filterlist){
  ## SNP_gene_bed = bed file of SNPs intersecting genes
  ## exons = GRanges object containing exon regions
  ## filterlist = list of gene IDs to filter
  
  # Load in the SNPs BED file
  SNPs <- readBed(SNP_gene_bed)
  # Get SNPs that overlap with transcripts
  SNPs.exons <- findOverlaps(SNPs,exons)
  SNPs <- SNPs[queryHits(SNPs.exons)]
  SNPs <- data.frame(SNPs)[,c(1,2,7)]
  names(SNPs) <- c("chr","pos","SNP_gene")
  # Create SNP and geneID columns by splitting SNP_gene on ":"
  SNPs$SNP <- as.character(map(strsplit(SNPs$SNP_gene,split = ":"), 1))
  SNPs$geneID <- as.character(map(strsplit(SNPs$SNP_gene,split = ":"), 2))
  # Filter SNPs in genes within filterlist
  SNPs <- SNPs[!SNPs$geneID%in%filterlist,]
  # Delete any duplicate rows and clean up
  SNPs <- SNPs[!duplicated(SNPs),]
  rm(SNPs.exons)
  
  # Output
  return(SNPs)
}

make_ASE_counts_matrix <- function(DIR_COUNTS,cores,SNPs){
  ## DIR_COUNTS = name of subdirectory containing count files
  ## cores = number of threads for parallel processing
  ## SNPs = dataframe generated by filter_SNPs2
  
  # Read in data
  ## List files ending in .txt in DIR_COUNTS
  SNP_counts <- data.frame(matrix(ncol=0,nrow=length(SNPs$SNP_gene)))
  SNP_counts$SNP_gene <- SNPs$SNP_gene
  files.counts <- list.files(path=DIR_COUNTS, pattern="*.txt", 
                             full.names=TRUE, recursive=FALSE)
  ## Left join count files by SNP_ID:geneID
  for(i in 1:length(files.counts)){
    print(i)
    tmp.name <-  strsplit(strsplit(files.counts[[i]], 
                                   split = "/")[[1]][length(strsplit(files.counts[[i]], 
                                                                     split = "/")[[1]])],
                          split = "[.]")[[1]][1]
    if(tmp.name%in%metadata$sample.id){
      tmp <- read.table(files.counts[[i]],header=F)[,c(4,7)]
      names(tmp) <- c("SNP_gene",tmp.name)
      SNP_counts <- SNP_counts %>% 
        left_join(tmp, by = c('SNP_gene' = 'SNP_gene')) 
    }
  }
  rm(tmp,files.counts,tmp.name)
  
  # Clean up dataframe
  row.names(SNP_counts) <- SNP_counts$SNP_gene
  SNP_counts$SNP_gene <- NULL
  SNP_counts[is.na(SNP_counts)] <- 0
  SNP_counts$gene <- as.character(map(strsplit(row.names(SNP_counts), split = ":"), 2))
  
  # Remove duplicate rows within genes
  genelist <- unique(SNP_counts$gene)
  delete.rows <- list()
  ## Use DoParallel to perform loop operation in parallel
  registerDoParallel(cores=cores)
  delete.rows <- foreach(i=1:length(genelist)) %dopar% {
    tmp <- SNP_counts[SNP_counts$gene==genelist[i],]
    d <- row.names(tmp[duplicated(tmp),])
    delete.rows <- return(d)
  }
  SNP_counts <- SNP_counts[!row.names(SNP_counts)%in%unlist(delete.rows),]
  
  # Output
  return(SNP_counts)
}

calcSizeFactors <- function(counts,mdata){
  ## counts = counts matrix generated by make_ASE_counts_matrix
  ## mdata = dataframe containing sample metadata
  
  # Merge parent-specific counts by library
  counts <- counts[,names(counts)%in%mdata$sample.id]
  counts_merged <- data.frame(matrix(ncol=0,nrow=length(row.names(counts))))
  samples <- unique(mdata$individual)
  for(i in 1:length(samples)){
    tmp <- counts[,names(counts)%in%mdata[mdata$individual==samples[i],"sample.id"]]
    tmp.merged <- rowSums(tmp)
    counts_merged <- cbind(counts_merged,tmp.merged)
  }
  names(counts_merged) <- samples
  mdata.merged <- mdata[,c("individual",
                           "phenotype",
                           "lineage")]
  mdata.merged <- mdata.merged[!duplicated(mdata.merged),]
  
  # Estimate library size factors using the median of ratios normalization method from DESeq2
  dds <- DESeqDataSetFromMatrix(countData = counts_merged, colData = mdata.merged, 
                                design = ~ lineage + phenotype)
  dds <- estimateSizeFactors(dds)
  sizeFactors <- sizeFactors(dds)
  sF2meta <- data.frame(individual=names(sizeFactors))
  sF2meta$sF <- as.numeric(sizeFactors)
  sF2meta <- left_join(sF2meta,mdata[,c("individual",
                                        "sample.id")],
                       multiple = "all")
  sF2meta <- sF2meta[,c(3,2)]
  sF2meta <- sF2meta[match(names(counts), sF2meta$sample.id),]
  sFs <- sF2meta$sF
  names(sFs) <- sF2meta$sample.id
  
  # Output
  return(sFs)
}

normalizeASReadCounts <- function(counts,size_factors){
  ## counts = counts matrix generated by make_ASE_counts_matrix
  ## size_factors = array from calcSizeFactors
  
  # Normalize counts for each library by parent
  mdata <- metadata[metadata$sample.id%in%names(counts),]
  counts <- counts[,names(counts)%in%mdata$sample.id]
  as.dds <- DESeqDataSetFromMatrix(countData = counts, colData = mdata, 
                                   design = ~ lineage+phenotype)
  sizeFactors(as.dds) = size_factors
  counts_normalized <- data.frame(counts(as.dds, normalized=TRUE))
  
  # Output
  return(counts_normalized)
}

filter_counts <- function(counts,lcf){
  # counts = phenotype-specific counts matrix
  # lcf = low count filter threshold (integer)
  
  # Remove rows with < lcf counts counts by Lineage
  LA <- metadata[metadata$lineage=="A","sample.id"]
  LB <- metadata[metadata$lineage=="B","sample.id"]
  counts <- counts[rowSums(counts[,names(counts)%in%LA])>lcf,]
  counts <- counts[rowSums(counts[,names(counts)%in%LB])>lcf,]
  
  # Flag rows with greater than 10000 counts
  ## Different functions are used for SK tests with < and > 10000 counts for computational efficiency
  counts$SUM <- rowSums(counts)
  counts$SKrow <- F
  counts[counts$SUM<10000,"SKrow"] <- T
  counts$SUM <- NULL
  
  # Remove genes with < 2 SNPs
  counts$gene <- as.character(map(strsplit(row.names(counts), split = ":"), 2))
  genelist <- unique(counts$gene)
  delete.rows <- list()
  for(i in 1:length(genelist)){
    tmp <- counts[counts$gene==genelist[i],]
    tmp <- tmp[!duplicated(tmp),]
    if(length(row.names(tmp))<2){
      delete.rows <- append(delete.rows,genelist[i])
    }
  }
  counts <- counts[!counts$gene%in%unlist(delete.rows),]
  counts$gene <- NULL
  
  # Return filtered counts
  return(counts)
}

twobinom<-function(r1,n1,r2,n2,alpha=.05){
  # r1 = success in group 1
  # n1 = total in group 1
  # r2 = success in group 2
  # r2 = total in group 2
  n1p<-n1+1
  n2p<-n2+1
  n1m<-n1-1
  n2m<-n2-1
  q <- r1/n1
  p <- r2/n2
  if(is.na(q)){q <- 0}
  if(is.na(p)){p <- 0}
  chk<-abs(q-p)
  x<-c(0:n1)/n1
  y<-c(0:n2)/n2  
  phat<-(r1+r2)/(n1+n2)
  m1<-t(Outer(x,y,"-"))
  m2<-matrix(1,n1p,n2p)
  flag<-(abs(m1)>=chk)
  m3<-m2*flag
  rm(m1,m2,flag)
  xv<-c(1:n1)
  yv<-c(1:n2)
  xv1<-n1-xv+1
  yv1<-n2-yv+1
  dis1<-c(1,pbeta(phat,xv,xv1))
  dis2<-c(1,pbeta(phat,yv,yv1))
  pd1<-NA
  pd2<-NA
  for(i in 1:n1){pd1[i]<-dis1[i]-dis1[i+1]}
  for(i in 1:n2){pd2[i]<-dis2[i]-dis2[i+1]}
  pd1[n1p]<-phat^n1
  pd2[n2p]<-phat^n2
  m4<-t(Outer(pd1,pd2,"*"))
  test<-sum(m3*m4)
  rm(m3,m4)
  list(p.value=test,p1=q,p2=p,est.dif=q-p)
}

AST.SK <- function(counts,phenotype,cores){
  # counts = phenotype-specific counts matrix
  # phenotype = corresponding phenotype of counts
  # cores = # of threads for multithreaded search
  
  # Split data by pat and mat
  pat.exp <- counts[,metadata[metadata$parent%in%c("M")&
                                metadata$phenotype==phenotype,"sample.id"]]
  mat.exp <- counts[,metadata[metadata$parent%in%c("F")&
                                metadata$phenotype==phenotype,"sample.id"]]
  # Set up for DoParallel
  SKrows=counts$SKrow
  registerDoParallel(cores=cores)
  i.len=length(row.names(pat.exp))
  
  # For each row, conduct an SK test and return the p-value
  return.df <- foreach(i=1:i.len, .combine=rbind,
                       .export=ls(globalenv()),.packages="Rfast") %dopar% {
                         SNP_gene=row.names(pat.exp[i,])
                         p1.s=sum(pat.exp[i,])
                         p2.s=sum(mat.exp[i,])
                         p.o=sum(p1.s,p2.s)
                         if(SKrows[i]==T){
                           test=twobinom(r1=p1.s,n1=p.o,
                                         r2=p2.s,n2=p.o)$p.value
                         }else{
                           test=fisher.test(matrix(c(p1.s,p2.s,
                                                     p2.s,p1.s),ncol = 2))$p.value
                         }
                         return.append=data.frame(SNP_gene=SNP_gene,p=test)
                         return(return.append)
                       }
  return.df=return.df[match(row.names(pat.exp), return.df$SNP_gene),]
  
  # Return
  return(return.df)
}

AST.GLIMMIX <- function(counts,size_factors,cores){
  # counts = phenotype-specific counts matrix
  # phenotype = corresponding phenotype of counts
  # cores = # of threads for multithreaded search
  # size_factors = object from calcSizeFactors
  
  sizeFactors <- data.frame(t(size_factors[names(size_factors)%in%names(counts)]))
  sizeFactors <- gather(sizeFactors, sample.id, sizeFactor, 
                        names(sizeFactors),factor_key=FALSE)
  counts$SNP_gene <- row.names(counts)
  counts$geneID <- as.character(unlist(map(strsplit(counts$SNP_gene, 
                                                    split = ":"), 2)))
  genelist <- unique(counts$geneID)
  registerDoParallel(cores=cores)
  i.len <- length(genelist)
  
  df.out <- foreach(i=1:i.len,.combine=rbind) %dopar% {
    counts.sub <- counts[counts$geneID==genelist[i],]
    counts.sub$geneID <- NULL
    counts.sub <- gather(counts.sub, sample.id, count, 
                         names(counts.sub), -SNP_gene, factor_key=TRUE)
    counts.sub <- join(counts.sub, metadata, by = "sample.id")
    counts.sub <- join(counts.sub,sizeFactors,by="sample.id")
    counts.sub$parent <- as.factor(str_sub(counts.sub$parent,-1,-1))
    counts.sub$SNP_gene <- as.factor(counts.sub$SNP_gene)
    counts.sub$lineage <- as.factor(counts.sub$lineage)
    counts.sub$individual <- as.factor(counts.sub$individual)
    testfail <- F
    test <- "null"
    tryCatchLog(test <- lmer(count~parent+lineage+parent*lineage+(1|SNP_gene)+
                               (1|individual)+offset(log(sizeFactor)),data=counts.sub), 
                error = function(e) {testfail <- T})
    if(class(test)=="character"){testfail <- T}
    if(testfail==F){
      test <- summary(test)
      parent.p.list <- test[["coefficients"]][2,5]
      Lineage.p.list <- test[["coefficients"]][3,5]
      parent.Lineage.p.list <- test[["coefficients"]][4,5]
    }else{
      parent.p.list <- 1
      Lineage.p.list <- 1
      parent.Lineage.p.list <- 1
    }
    return(data.frame(ID=genelist[i],
                      parent.p=parent.p.list,
                      Lineage.p=Lineage.p.list,
                      parentXLineage.p=parent.Lineage.p.list))
  }
  return(df.out)
}

AST.Analysis <- function(counts,phenotype,SK,GLIMMIX){
  # counts = phenotype-specific count matrix
  # phenotype = corresponding phenotype of counts
  # SK = object from AST.SK
  # GLIMMIX = object from AST.GLIMMIX
  
  # Split count matrices by lineage and parent for plotting
  counts <- counts[,names(counts)%in%metadata$sample.id]
  p1.pat <- counts[,metadata[metadata$parent%in%c("M")&metadata$lineage=="B"&metadata$phenotype==phenotype,"sample.id"]]
  p1.mat <- counts[,metadata[metadata$parent%in%c("F")&metadata$lineage=="B"&metadata$phenotype==phenotype,"sample.id"]]
  p2.pat <- counts[,metadata[metadata$parent%in%c("M")&metadata$lineage=="A"&metadata$phenotype==phenotype,"sample.id"]]
  p2.mat <- counts[,metadata[metadata$parent%in%c("F")&metadata$lineage=="A"&metadata$phenotype==phenotype,"sample.id"]]
  
  # Set up a data.frame to plot p1 and p2 for each SNP
  p1.plot <- data.frame(rowSums(p1.pat)/(rowSums(p1.mat)+rowSums(p1.pat)))
  names(p1.plot) <- c("p1")
  p1.plot[is.nan(p1.plot$p1),"p1"] <- 0
  p2.plot <- data.frame(rowSums(p2.mat)/(rowSums(p2.mat)+rowSums(p2.pat)))
  names(p2.plot) <- c("p2")
  p2.plot[is.nan(p2.plot$p2),"p2"] <- 0
  plot <- cbind(p1.plot,p2.plot)
  
  # Join results of Storer-Kim tests
  plot <- plot[row.names(plot)%in%SK$SNP_gene,]
  plot$SK.p <- SK$p
  plot$SNP_gene <- row.names(plot)
  plot$gene <- as.character(map(strsplit(plot$SNP_gene, split = ":"), 2))
  
  # Reformat output from GLIMMMIX models
  GLIMMIX.biased <- data.frame(gene=GLIMMIX$ID,
                               parent.p=GLIMMIX$parent.p,
                               Lineage.p=GLIMMIX$Lineage.p,
                               parentXLineage.p=GLIMMIX$parentXLineage.p)
  
  # Correct for multiple testing
  plot$SK.padj <- p.adjust(plot$SK.p,"BH")
  plot$bias <- "NA"
  GLIMMIX$parent.padj <- p.adjust(GLIMMIX$parent.p,"BH")
  GLIMMIX$Lineage.padj <- p.adjust(GLIMMIX$Lineage.p,"BH")
  GLIMMIX$parentXLineage.padj <- p.adjust(GLIMMIX$parentXLineage.p,"BH")
  GLIMMIX.biased <- GLIMMIX[GLIMMIX$parent.padj<0.05|GLIMMIX$Lineage.padj<0.05,1]
  GLIMMIX.biased <- setdiff(GLIMMIX.biased,GLIMMIX[GLIMMIX$parentXLineage.padj<0.05,1])
  
  # For each gene, check whether all SNPs are biased in the same direction at established thresholds
  ## Genes with parentXLineage effects are flagged as unbiased
  for(i in 1:length(row.names(plot))){
    p <- plot[i,"SK.padj"]
    p1 <- plot[i,"p1"]
    p2 <- plot[i,"p2"]
    if(p<0.05&p1>0.6&p2<0.4){plot[i,"bias"] <- "pat"}
    if(p<0.05&p1<0.4&p2>0.6){plot[i,"bias"] <- "mat"}
    if(p<0.05&p1<0.4&p2<0.4){plot[i,"bias"] <- "Lineage B"}
    if(p<0.05&p1>0.6&p2>0.6){plot[i,"bias"] <- "Lineage A"}
  }
  biaslist <- data.frame(matrix(ncol=2,nrow=0))
  names(biaslist) <- c("gene","bias")
  genelist <- unique(plot$gene)
  for(i in 1:length(genelist)){
    tmp <- unique(plot[plot$gene==genelist[i],"bias"])
    if(length(tmp)>1){
      if(length(tmp)==2){
        if(any(tmp%in%"NA")){
          bias <- tmp[!tmp%in%"NA"]
        }else{bias <- "NA"}
      }else{
        bias <- "NA"
      }
    }else{bias <- tmp}
    biaslist <- rbind(biaslist,data.frame(gene=genelist[[i]], bias=bias))
  }
  plot <- plot %>% left_join(biaslist, by = c('gene' = 'gene')) 
  names(plot)[c(7:8)] <- c("xbias","bias")
  plot$bias.plot <- "NA"
  for(i in 1:length(row.names(plot))){
    p1 <- plot$p1[i]
    p2 <- plot$p2[i]
    bias <- plot$bias[i]
    if(!bias=="NA"){
      if(bias=="pat"){if(p1>0.6&p2<0.4){plot[i,"bias.plot"]<- "pat"}}
      if(bias=="mat"){if(p1<0.4&p2>0.6){plot[i,"bias.plot"] <- "mat"}}
      if(bias=="Lineage B"){if(p1<0.4&p2<0.4){plot[i,"bias.plot"] <- "Lineage B"}}
      if(bias=="Lineage A"){if(p1>0.6&p2>0.6){plot[i,"bias.plot"] <- "Lineage A"}}
    }
  }
  plot[!plot$gene%in%GLIMMIX.biased,"bias.plot"] <- "NA" 
  plot <- rbind(plot[plot$bias.plot%in%c("NA"),],
                plot[plot$bias.plot%in%c("mat", "Lineage A", "Lineage B", "pat"),])
  plot$bias.plot <- factor(plot$bias.plot,
                           levels = c("NA","mat", "Lineage A", "Lineage B", "pat"))
  
  # Return
  return(plot)
}

AST.chisq <- function(pheno1.label,pheno1.plot,
                      pheno2.label,pheno2.plot,
                      allgenes){
  # pheno1.label = label for phenotype 1
  # pheno1.plot = object from AST.Analysis
  # pheno2.label = label for phenotype 2
  # pheno2.plot = object from AST.Analysis
  # allgenes = list containing background set of genes
  
  # Collapse pheno plots by gene
  pheno1.plot <- pheno1.plot[,c("gene","bias.plot")]
  pheno1.plot <- pheno1.plot[!duplicated(pheno1.plot),]
  pheno2.plot <- pheno2.plot[,c("gene","bias.plot")]
  pheno2.plot <- pheno2.plot[!duplicated(pheno2.plot),]
  
  # Quantify genes in each category of bias and combine into a table
  gmid.df <- data.frame(
    Unresponsive=c(length(unique(pheno1.plot[pheno1.plot$bias.plot=="mat","gene"])),
                   length(unique(pheno1.plot[pheno1.plot$bias.plot=="Lineage A","gene"])),
                   length(unique(pheno1.plot[pheno1.plot$bias.plot=="Lineage B","gene"])),
                   length(unique(pheno1.plot[pheno1.plot$bias.plot=="pat","gene"]))),
    Bias=c("mat","Lineage A","Lineage B","pat"),
    Responsive=c(length(unique(pheno2.plot[pheno2.plot$bias.plot=="mat","gene"])),
                 length(unique(pheno2.plot[pheno2.plot$bias.plot=="Lineage A","gene"])),
                 length(unique(pheno2.plot[pheno2.plot$bias.plot=="Lineage B","gene"])),
                 length(unique(pheno2.plot[pheno2.plot$bias.plot=="pat","gene"]))))
  
  # Perform Chi-squared tests
  mat.test <- chisq.test(data.frame(Success=c(gmid.df[1,1],gmid.df[1,3]),
                                    Failure=c(length(allgenes)-gmid.df[1,1],
                                              length(allgenes)-gmid.df[1,3]),
                                    row.names=c(pheno1.label,pheno2.label)),
                         correct=F)$p.value
  
  LineageA.test <- chisq.test(data.frame(Success=c(gmid.df[2,1],gmid.df[2,3]),
                                         Failure=c(length(allgenes)-gmid.df[2,1],
                                                   length(allgenes)-gmid.df[2,3]),                                           row.names=c(pheno1.label,pheno2.label)),
                              correct=F,simulate.p.value = TRUE)$p.value
  
  LineageB.test <- chisq.test(data.frame(Success=c(gmid.df[3,1],gmid.df[3,3]),
                                         Failure=c(length(allgenes)-gmid.df[3,1],
                                                   length(allgenes)-gmid.df[3,3]),
                                         row.names=c(pheno1.label,pheno2.label)),
                              correct=F,simulate.p.value = TRUE)$p.value
  
  pat.test <- chisq.test(data.frame(Success=c(gmid.df[4,1],gmid.df[4,3]),
                                    Failure=c(length(allgenes)-gmid.df[4,1],
                                              length(allgenes)-gmid.df[4,3]),
                                    row.names=c(pheno1.label,pheno2.label)),
                         correct=F)$p.value
  
  # Build table for plotting
  names(gmid.df) <- c(pheno1.label,"Bias",pheno2.label)
  gmid.df$p <- c(mat.test,LineageA.test,LineageB.test,pat.test)
  gmid.df <- gmid.df[,c(4,1,2,3)]
  nsrows <- row.names(gmid.df[gmid.df$p>0.05,])
  gmid.df$p <- formatC(gmid.df$p, format = "e", digits = 2)
  gmid.df[nsrows,"p"] <- "(ns)"
  gmid.df <- gmid.df[,c(2,3,4,1)]
  
  # Output
  return(gmid.df)
}

AST.collapse <- function(data.plot,data.counts,phenotype){
  # data.plot = object from AST.Analysis
  # data.counts = phenotype-specific counts matrix
  # phenotype = corresponding phenotype of data.plot and data.counts
  
  # Wrangle data
  data.counts <- data.counts[,names(data.counts)%in%metadata$sample.id]
  data.counts$SNP_gene <- row.names(data.counts)
  data <- data.plot %>% 
    left_join(data.counts, by = c('SNP_gene' = 'SNP_gene')) 
  genelist <- unique(data$gene)
  p1.mean <- list()
  p2.mean <- list()
  biaslist <- list()
  altbias <- list()
  
  # Collapse SNPs by gene
  for(i in 1:length(genelist)){
    tmp <- data[data$gene==genelist[i],]
    altbias[i] <- as.character(tmp$bias)[1]
    if(!any(tmp$bias=="NA") & length(tmp[!tmp$bias.plot=="NA","p1"])>0){
      tmp.sub <- tmp[!tmp$bias.plot=="NA",]
      # Split count matrices by Lineage and parent of origin for plotting
      p1.pat <- tmp.sub[,metadata[metadata$parent%in%c("M")&metadata$lineage=="B"&metadata$phenotype==phenotype,"sample.id"]]
      p1.mat <- tmp.sub[,metadata[metadata$parent%in%c("F")&metadata$lineage=="B"&metadata$phenotype==phenotype,"sample.id"]]
      p2.pat <- tmp.sub[,metadata[metadata$parent%in%c("M")&metadata$lineage=="A"&metadata$phenotype==phenotype,"sample.id"]]
      p2.mat <- tmp.sub[,metadata[metadata$parent%in%c("F")&metadata$lineage=="A"&metadata$phenotype==phenotype,"sample.id"]]
      p1.mean.x <- mean(sum(p1.pat)/(sum(p1.mat)+sum(p1.pat)))
      if(is.nan(p1.mean.x)){p1.mean.x <- 0}
      if(is.infinite(p1.mean.x)){p1.mean.x <- 1}
      p1.mean[i] <- p1.mean.x
      p2.mean.x <- mean(sum(p2.mat)/(sum(p2.mat)+sum(p2.pat)))
      if(is.nan(p2.mean.x)){p2.mean.x <- 0}
      if(is.infinite(p2.mean.x)){p2.mean.x <- 1}
      p2.mean[i] <- p2.mean.x
      biaslist[i] <- as.character(tmp.sub$bias.plot[1])
    }else{
      p1.mean[i] <- mean(tmp$p1)
      p2.mean[i] <- mean(tmp$p2)
      biaslist[i] <- "NA"}}
  return.data <- data.frame(gene=unlist(genelist),
                            bias.plot=unlist(biaslist),
                            p1=unlist(p1.mean),
                            p2=unlist(p2.mean),
                            altbias=unlist(altbias))
  return.data$bias.plot <- factor(return.data$bias.plot,
                                  levels = c("NA","mat", "Lineage A", "Lineage B", "pat"))
  return.data <- return.data[order(return.data$bias.plot),]
  
  # Output
  return(return.data)
}

AST.scatter <- function(data,title,
                        LineageA.color.dark="#058762",LineageA.color.light="#4dc4a2",
                        LineageB.color.dark="#f7af05",LineageB.color.light="#f7ca60"){
  # data = object from AST.collapse
  # title = string, title of plot
  
  get_density <- function(x, y, ...){
    dens <- MASS::kde2d(x, y, ...)
    ix <- findInterval(x, dens$x)
    iy <- findInterval(y, dens$y)
    ii <- cbind(ix, iy)
    return(dens$z[ii])}
  
  data$bias.plot <- factor(data$bias.plot)
  biases <- levels(data$bias.plot)
  data$color <- NA
  for(i in 1:length(biases)){
    data.sub <- data[data$bias.plot==biases[i],]
    if(length(data.sub$gene)>2){
      density <- get_density(data.sub$p1, data.sub$p2, n = 100)
      if(biases[i]=="NA"){pal <- colorRampPalette(colors = c("grey90", "grey70"))(60)}
      if(biases[i]=="pat"){pal <- colorRampPalette(colors = c("#a1d2ed", "#02a0f5"))(60)}
      if(biases[i]=="mat"){pal <- colorRampPalette(colors = c("grey50", "black"))(60)}
      if(biases[i]=="Lineage A"){pal <- colorRampPalette(colors = c(LineageA.color.light,
                                                                    LineageA.color.dark))(60)}
      if(biases[i]=="Lineage B"){pal <- colorRampPalette(colors = c(LineageB.color.light,
                                                                    LineageB.color.dark))(60)}
      data[data$bias.plot==biases[i],"color"] <- smoothPalette(density,pal=pal)
    }
    if(length(data.sub$gene)<=2){
      if(biases[i]=="NA"){pal <- "grey90"}
      if(biases[i]=="pat"){pal <- "#a1d2ed"}
      if(biases[i]=="mat"){pal <- "grey50"}
      if(biases[i]=="Lineage A"){pal <- LineageA.color.light}
      if(biases[i]=="Lineage B"){pal <- LineageB.color.light}
      data[data$bias.plot==biases[i],"color"] <- pal
    }
  }
  data <- data[,c(3,4,6)]
  data <- data[!duplicated(data),]
  
  # Generate plot
  g <- ggplot(data, aes(x=p1, y=p2,
                        color=color)) +
    geom_point(size=3) + theme_prism() +
    xlab(expression(bold(paste("% A allele in ",B[mother],
                               " x ",A[father],sep="")))) +
    ylab(expression(bold(paste("% A allele in ",A[mother],
                               " x ",B[father],sep="")))) +
    ggtitle(title) +
    theme(text = element_text(size=18),
          plot.title = element_text(hjust = 0.5)) +
    guides(alpha=F, color=F) +
    scale_x_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) +
    scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, .2)) +
    scale_colour_identity()
  
  # Output
  return(g)
}

AST.scatter.table <- function(chisq.df,
                              LineageA.color="#009e73",
                              LineageB.color="#e69f00"){
  # chisq.table = table generated by AST.chisq
  
  # Build table plot
  gmid.df <- chisq.df
  
  cols <- matrix("black", nrow(gmid.df), ncol(gmid.df))
  cols[1,2] <- "#000000"
  cols[2,2] <- LineageA.color
  cols[3,2] <- LineageB.color
  cols[4,2] <- "#56b4e9"
  
  ccols <- matrix("white", nrow(gmid.df), ncol(gmid.df))
  
  ccols[1:4,3] <- "#f4efea"
  ccols[1:4,1] <- "#f4efea"
  ccols[1:4,2] <- "#e4d8d1"
  
  cfonts <- matrix("bold", nrow(gmid.df), ncol(gmid.df))
  
  gmid.df[2,2] <- "A"
  gmid.df[3,2] <- "B"
  
  tt <- ttheme_default(core=list(fg_params = list(col = cols,
                                                  cex = 1,
                                                  fontface = cfonts),
                                 bg_params = list(col=NA, fill = ccols),
                                 padding.h=unit(2, "mm")),
                       rowhead=list(bg_params = list(col=NA)),
                       colhead=list(bg_params = list(fill =c("#f4efea",
                                                             "#e4d8d1",
                                                             "#f4efea",
                                                             "white")),
                                    fg_params = list(rot=90,
                                                     cex = 1,col=c("black",
                                                                   "black",
                                                                   "black",
                                                                   "white"))))
  
  # Generate plot
  gmid <- tableGrob(gmid.df, rows = NULL, theme=tt)
  
  # Output
  return(gmid)
}